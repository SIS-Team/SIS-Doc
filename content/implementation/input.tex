\subsection{Eingaben}
% Hier musst du nicht total ins Detail gehen, weil ja alles im Wesentlichen klar ist.
%
% Hier dürfen auch auch Sourcecode-Teile vorkommen.
% Wenn Sourcecodes: jeweilge File in den Ordner /sources/ in einen Unterordner packen und mit folgendem Befehl includieren:
%
%
% \lstinputlisting[style=custom, language=php, caption={Dateiname}, label={lst:content_imple_timetables_labelname}]{sources/ordner/datei.php}
%
% Als weitere Eigenschaft kannst du die Zeilen angeben: [firstline=300, lastline=500]
% Damit nicht alles reinkopiert wird.
Wie schon bei \autoref{sec:content_draft_form} erwähnt, ist es nicht möglich für alle Eingabemasken die selbe Routine zu verwenden, deshalb werden auch hier die Routinen in 3 Teile geteilt. In die Routine für die normalen Eingabemasken, in die Eingabemaske für die Supplierungen und in die Eingabemaske für die Stundenpläne.
\subsubsection{Routine für die normalen Eingabemasken}
Für die Normale Eingabemaske gibt es eine Funktion mit dem Namen \texttt{form\_new}, dieser Funktion müssen 3 Parameter mitgegeben werden. Ein Parameter ist der Aufbau einer Eingabezeile (Variable \texttt{\$field}), der zweite ist der Inhalt (Variable \texttt{\$content}) und der letzte Parameter ist ein Objekt, das für die Sicherheit der Formulare benötigt wird. (siehe \autoref{sec:content_draft_token})\\
Da jede Eingabezeile einen Datensatz einer MySQL Tabelle widerspiegelt,
müssen diese Zeilen dem Datensatz zugeordnet werden können. Um dies zu realisieren wird im \$field Array ein \textit{Hidden}-Feld definiert. Deisem wird nach dem Erstellen beim Befüllen mit Daten die eindeutige ID des Datensatzes als Wert zugewiesen. Dieses Feld ist auf der Seite vorhanden, wird jedoch nicht auf der Seite dargestellt. Drückt der Anwender auf Übernehmen, so wird der Wert des \textit{Hidden}-Feldes mitgegeben und somit kann die Zeile identifiziert werden.\\
\paragraph{Parameter \texttt{\$field}\\}
Dieser Parameter ist ein mehrdimensionales Array, welches, wie bei \autoref{lst:content_imple_input_bsp} Zeile 43-50 zu sehen, auszusehen hat. Hier ist als Beispiel eine Definition dieses Arrays für die Eingabemaske der Lehrer dargestellt.\\
Der Aufbau ist recht simpel. Jede Zeile entspricht einem Input-Feld und jede Spalte entspricht einer Eigenschaft des Input-Felds. In der Tabelle \autoref{tab:content_imple_inout_array} ist die Funktion der einzelnen Spalten im Array beschrieben.
\begin{table}[H]
\centering
\begin{tabular}{p{2 cm}p{8 cm}p{3 cm}}
   \toprule
   \textbf{Spalte} & \textbf{Auswirkung} & \textbf{Beispiel} \\
   \midrule
          \textbf{1. Spalte} & Name des Input-Feldes \newline Spaltenbezeichnung in der MySQL-Tabelle \newline Pflichtspalte & date  \\
          \hline
          \textbf{2. Spalte} & Input-Typ \newline Pflichtspalte & siehe Abschnitt \nameref{sec:content_imple_input_type} \\
          \hline
          \textbf{3. Spalte} & Anzeigename \newline Pflichtspalte & Datum \\
          \hline
          4. Spalte & Größe 1 \newline Breite des Input-Feldes \newline Optional & 10\\
          \hline
          5. Spalte & Größe 2 \newline nur bei Textarea benötigt \newline Länge der Textarea \newline Optional & 5\\
          \hline
          6. Spalte & Inhalt \newline hier kann ein Inhalt vordefiniert werden  \newline Optional & true\\
          \hline
          7. Spalte & Sonstiges \newline jegliche Eigenschaften für ein Input-Typ \newline Optional & required \\
   \bottomrule
\end{tabular}
\caption{Array \$field}
\label{tab:content_imple_inout_array}
\end{table}
Mit diesen Eigenschaften können beliebige Eingabemasken erstellt werden, die einzige Voraussetzung ist, dass sich alle Input-Felder in einer Zeile  befinden müssen.\\
Für eine bessere Darstellung befindet sich jede Zeile in einer eigenen Tabelle. Jedes Input-Feld in einer eigenen Zelle. Jede Tabelle wird mit einem Formular umschlossen. Somit entspricht jede Zeile einem eigenen Formular. Dies hat zur Folge, dass jede Zeile eigens bearbeitet werden kann.\\
Eine Idee war, dass alle Zeilen in einer Tabelle sind, dies ist jedoch nicht so einfach realisierbar, da die leere Zeile keine Löschfunktion hat und somit auch weniger Spalten. Dies mit ein zu beziehen würde es unnötig verkomplizieren. Somit wurde diese Möglichkeit nicht verwendet.
\paragraph{Parameter \$content\\}
Mit diesem Funktionsparameter werden die Inhalte der Input-Felder mitgegeben. Wird diesem Parameter ein \texttt{false} mitgegeben, so wird eine leere Zeile erstellt. Soll jedoch die Zeile mit Inhalt befüllt werden, so wird dieser Variable ein eindimensionales Array mitgegeben. Diese Routine wurde so konzipiert, dass dieser Inhalt einem Datensatz des MySQL-Querys, der mit der Funktion \texttt{mysql\_fetch\_array} verarbeitet wurde, entspricht. (siehe \autoref{lst:content_imple_input_bsp} Zeile 56)\\
Mit der \textit{While-Schleife}, in Zeile 56-58 im \autoref{lst:content_imple_input_bsp}, werden alle zurückgegebenen Datensätze einzeln verarbeitet und der Funktion \texttt{form\_new} mitgegeben. Dadurch wird für jeden einzelnen Datensatz eine Zeile erstellt.\\
Auf den Inhalt wird mittels Array-Index zugegriffen. Dieser Index entspricht der im Query definierten Spaltenbezeichnungen. Um die richtigen Inhalte dem richtigen Input-Feldern zuweisen zu können, ist es wichtig, dass die 1. Spalte des \$field-Arrays mit der Spaltenbezeichnung übereinstimmt. Dies hat den Grund, dass die Inhalte mit den Input-Feldern über diese Information miteinander verknüpft werden.\\
Eine große Rolle spielt auch die 6. Spalte des \$field-Arrays, da in der Erstell-Routine der Inhalt in diese Spalte geschrieben wird. Somit wird auch der vordefinierte Wert des Input-Feldes überschrieben.\\

\lstinputlisting[style=custom, language=php, caption={/backend/administration/teachers/index.php; Zeile 42 - 64},  label={lst:content_imple_input_bsp}, linerange={42-64}, firstnumber=42 ]{sources/input/teacher.php}

\paragraph{Routine\\}
In diesem Abschnitt wird ausschließlich der \autoref{lst:content_imple_input_form} behandelt. Alle Zeilenangaben beziehen sich auf diesen Code.\\
\\
In Zeile 41 ist der Beginn der \textit{foreach}-Schleife definiert. Diese Schleife spaltet das Array auf und durchläuft dieses Array Zeilenweise. Mit jedem Durchlauf springt der Pointer um eine Zeile weiter bis das Array durchlaufen ist. Dabei \enquote{kopiert} die Funktion die momentane Zeile in die Variable \texttt{\$f}, so beinhaltet diese Variable immer die momentane Zeile als eindimensionales Array. Somit muss nicht mit 2 Indizes auf den Inhalt zugegriffen werden.\\
In Zeile 43 - 46 wird der Inhalt mit dem jeweiligen Input-Feld zusammengeführt. Zuvor wird in Zeile 43 abgefragt, ob ein Inhalt übergeben wurde. Wenn ein Inhalt übergeben wird, dann muss dieser bearbeitet werden. Mit dem Namen des Input-Feldes wird im \texttt{\$content} auf den jeweiligen Inhalt zugegriffen. Dieser wird anschließend in die dafür vorgesehene Spalte im \texttt{\$f}-Array geschrieben.\\
Ab Zeile 48 bis Zeile 84 werden in einer \textit{If}-Abfrage alle einzelnen Typen behandelt. Trifft eine Abfrage zu, so wird dieses Input-Feld erzeugt, dabei werden alle Eigenschaften, die im \texttt{\$field} Array definiert wurden, dementsprechend berücksichtigt.\\
Ist das Array \texttt{\$field} durchlaufen werden die Zeilen ab 86 durchlaufen. In Zeile 86 wird die aufgerufene URL in die einzelnen Teile zerlegt, dies ist notwendig, um zu bestimmen mit welche Parametern die Funktion \texttt{form\_savedelete} (siehe \autoref{sec:content_input_savedelete}) aufgerufen werden soll, denn nicht in allen Eingaben soll Löschen möglich sein.\\
In den Zeilen 88 - 99 wird zwischen den Parametern entschieden, mit denen die Funktion aufgerufen werden soll.
\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 41 - 99}, label={lst:content_imple_input_form}, linerange={41-99},firstnumber=41 ]{sources/input/form.php}
\paragraph{Input-Typen} \label{sec:content_imple_input_type}
$~~$ \\
In dieser Routine werden nur die benötigten Typen definiert. Dazu gehören folgende:
\begin{table}[H]
\centering
\begin{tabular}{p{4.5 cm}p{10.5 cm}}
   \toprule
   \textbf{Name für Definition} & \textbf{Input-Art} \\
   \midrule
          checkbox & Check Box  \\
          \hline
          text & Textbox \\
          \hline
          date & Textbox mit Datumsauswahl (nur bestimmte Browser) \\
          \hline
          textarea & Textarea für lange Texte\\
          \hline
          Button & Button zum absenden von Formularen\\
          \hline
          hidden & Unsichtbares Feld \\
          \hline
          dropdown & Listenfeld \\
   \bottomrule
\end{tabular}
\caption{Input-Typen}
\end{table}
\subsubsection{Routine für die Eingabe der Supplierungen}
Da für die Eingabe der Supplierungen eine andere Eingabemaske nötig ist, wurde eine eigene Routine entwickelt.\\
Durch die Tatsache, dass eine Eingabezeile aus 2 Zeilen besteht, sind hier 2 Arrays für den Aufbau nötig. Der Parameter \texttt{\$fieldRow1} beschreibt die erste und der Parameter \texttt{\$fieldRow2} die zweite Zeile. Weiteres muss dieser Funktion das Kürzel der Abteilung mitgegeben werden. Damit wieder die richtigen GET Parameter an die URL angehängt werden. (Variable \texttt{\$content}) Die restlichen Parameter erfüllen den gleichen Nutzen wie bei der normalen Routine. Der Aufbau der beiden \texttt{\$field}-Parametern entspricht dem gleichen wie bei der normalen Routine.\\
\paragraph{Routine\\}
Um den Code besser erklären zu können wird er in mehrere Teile zerlegt.\\
\\
\begin{enumerate}
	\item \autoref{lst:content_imple_input_substitudes_1}\\
	Von Zeile 221 bis Zeile 239 werden einige Variablen vordefiniert. Diese sind notwendig, da einige Check Boxen standardmäßig aktiviert oder nicht aktiviert sein sollen. Außerdem sind einige Felder oder Zeilen nicht immer sichtbar, um dies so gut wie möglich zu steuern, wurde für jedes Element eine dementsprechende Variable definiert, welche an den notwendigen Stellen zum Einsatz kommt. Die Variablen sind jeweils als Arrays ausgeführt. Das Array \texttt{\$display} ist notwendig, um zu steuern welche Felder und Zeilen sichtbar sind. Das Array \texttt{\$checked} ist für die Steuerung der Check Boxen notwendig.
	Im Folgendem werden die möglichen Werte, die die Variablen annehmen können, beschrieben:
	\begin{itemize}
		\item none: Feld/Zeile nicht sichtbar
		\item table-cell: Feld ist als Tabellen-Zelle sichtbar
		\item table-row: Zeile ist als Tabellen-Zeile sichtbar
		\item checked : Check Box ist aktiviert
		\item \enquote{}: Check Box ist deaktiviert
	\end{itemize}
	Da diese Werte abhängig von der ausgewählten Eingabeart der Supplierungen sind, muss die Zuweisung der Variablen unter Umständen abgeändert werden.\\
	In den Zeilen 241 - 244 wird die Farbe des Striches unter jeder Eingabezeile definiert. Diese wird rot eingefärbt, wenn ein Fehler aufgetreten ist. Ist ein Fehler aufgetreten, ist der Inhalt nicht aus einer MySQL Abfrage, sondern wird direkt aus den Werten entnommen, welche über POST der Webseite übergeben werden. Wird der Inhalt aus den POST-Variablen entnommen, dann gibt es eine Variable mit dem Namen \texttt{hash}, daraus kann geschlossen werden, dass es eine Fehleingabe ist und der Strich rot eingefärbt werden muss, sonst wird er weiß eingefärbt.\\
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile  221 - 244},  label={lst:content_imple_input_substitudes_1}, linerange={221-244}, firstnumber=221 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_substitudes_2}\\
	Da die Bezeichnung der Radio Buttons in den POST-Variablen nicht mit den Bezeichnungen aus der MySQL-Abfrage übereinstimmt, muss aus den POST-Variablen die richtigen Bezeichnungen für die weitere Verarbeitung herausgelesen werden. Dazu werden in der Variabel \texttt{\$content} die richtigen Werte gesetzt. Dies ist in den Zeilen 246 - 253 zu sehen.\\
	Aufgrund der gesetzten Radio Buttons oder Check Boxen muss nun entschieden werden was sichtbar gemacht wird. Dazu gibt es in den Zeilen 255 - 293 \textit{If}-Abfragen, mit denen zwischen den einzelnen Modi unterschieden wird.\\ 
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile  246 - 267},  label={lst:content_imple_input_substitudes_2}, linerange={246-267}, firstnumber=255 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_substitudes_3}\\
	Ab der Zeile 303 bis zur Zeile 338 wird die erste Zeile erstellt. Dies geshieht im wesentlichen nach dem selben Prinzip wie bei der normalen Routine, jedoch bekommen hier die einzelnen Input-Typen eine \texttt{id}. Mit dieser \texttt{id} kann man mit JavaScript auf die Input-Typen zugreifen.(siehe Abschnitt \nameref{sec:content_imple_input_java_supp}) Diese \texttt{id} setzt sich aus dem Typ und der ID des Datensatzes in der MySQL Tabelle zusammen. Bei manchen wird noch der eindeutige Spaltenname angefügt.\\
	Zum Beispiel:
	\begin{itemize}
		\item Eine Zeile von dem Datensatz mit der ID 2 hat folgende \texttt{id} : visibleRow2
		\item Ein Input-Feld mit dem Namen date aus der Zeile des Datensatzes mit der ID 3 hat folgende \texttt{id} : visibleCell3date
	\end{itemize}
	Durch diese Bezeichnung lässt sich jede Zeile und Input-Feld eindeutig innerhalb der Eingabe definieren.\\
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile  303 - 338},  label={lst:content_imple_input_substitudes_3}, linerange={303-338}, firstnumber=303 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_substitudes_4}\\
	Ab Zeile 360 wird die zweite Zeile erstellt. Dies funktioniert nach dem selben Prinzip wie zuvor.\\
	Die Verfügbaren Input-Typen wurden angepasst und auf die notwendigen reduziert. Außerdem wurde ein Typ neu erstellt, dieser nennt sich \texttt{checkboxJava}. Dies ist eine Check Box, die als \texttt{oncklick}-Event eine Funktion hinterlegt hat, welche zum Umstrukturieren nötig ist. (siehe dazu Abschnitt \nameref{sec:content_imple_input_java_supp})	
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile  360 - 371},  label={lst:content_imple_input_substitudes_4}, linerange={360-371}, firstnumber=360 ]{sources/input/form.php}
\end{enumerate}
\paragraph{Supplierung JavaScript} $ ~~ $\\
\label{sec:content_imple_input_java_supp}
Für die Eingabe der Supplierungen wurde ein wenig JavaScript benötigt. Dies beschränkt sich auf eine Funktion, die das ein- und ausblenden der Eingabeelemente übernimmt.\\
Dieser Funktion werden 2 Parameter mitgegeben, zum einen um welche Eingabezeile handelt es sich (\texttt{id}) und welches Element ruft die Funktion auf (\texttt{typ}).\\
Mit der Unterscheidung des Typs wird bestimmt, welche Elemente ein- bzw. ausgeblendet werden müssen.\\
Mit der Methode \texttt{getElementById} des \texttt{document}-Objektes kann das jeweilige HTML-Element ausgewählt werden. Ausgewählt wird in diesem Fall, wie der Name der Methode ja bereits andeutet, über die ID des Elementes, diese wird als Parameter der Methode mitgegeben. Zurückgeliefert wird ein DOM-Objekt über dessen Eigenschaften auf die Attribute und Eigenschaften des HTML-Elementes zugegriffen werden kann.\\
Hier die von mir verwendeten Eigenschaften:
\begin{itemize}
	\item \texttt{style.display} : greift auf die Style Eigenschaftes im Element zu und verändert die Eigenschaft Display
	\item \texttt{value} : greift auf den Wert des Elementes zu und ändert diesen
	\item \texttt{checked} : ändert den Zustand der CheckBox oder Radio Buttons in den aktivierten(true) oder deaktivierten(false) Zustand
\end{itemize}
JavaScript wird hier benötigt, da das Aus- und Einblenden ohne neu Laden des Browsers geschehen muss. Dies kann nur mit JavaScript realisiert werden.\\
Im folgendem Codeausschnitt ist ein Teil der \textit{If}-Abfrage zur unterscheidung zwischen den verschiedenen Typen zu sehen.
\lstinputlisting[style=custom, language=java, caption={data/scripts/substitudes.js; Zeile 10 - 20},  label={lst:content_imple_input_substitudes_java}, firstline =10, lastline = 20, firstnumber = 10 ]{sources/input/substitudes.js}
\subsubsection{Routine für die Eingabe der Stundenpläne}
Die Eingabemaske der Stundenpläne wird nach einem komplett anderen Prinzip erstellt. Denn bei dieser Eingabemaske erscheint nicht nach einer Eingabe eine neue Zeile, sondern es werden alle Zeilen beim Laden der Seite erstellt. Auch die nicht sichtbaren Zeilen für die Teilungen werden erstellt, jedoch nicht dargestellt. Um diese einzublenden wird JavaScript benötigt. (siehe Abschnitt \nameref{sec:content_imple_input_java_lessons})\\
Die Funktion, die für das Erstellen der Eingabemaske zuständig ist, heißt \texttt{form\_lesson} und benötigt 3 Parameter. Der \texttt{\$field} Parameter ist gleich aufgebaut wie in den anderen Routinen. Der zweite Paramter ist der \texttt{\$content} Parameter, diese Variable unterscheidet sich, von den anderen Routinen. Die letzte Variable ist, wie auch zuvor, für die Sicherheit notwendig.
\paragraph{Parameter \texttt{\$content}\\}
Dieser Parameter wird hier als einziges behandelt, da sich dieser Aufbau wesentlich geändert hat. Bei den anderen Routinen wurde jede einzelne Tabellenzeile an die Funktion übergeben, dies ist durch den veränderten Aufbau der Eingabemaske nicht mehr möglich, deshalb werden hier zuerst alle Zeilen in ein mehrdimensionales Array geschrieben, anschließend wird dieses Array an die Funktion übergeben. Wie auch in den anderen Routinen werden die einzelnen Rückgabewerte mit einer \textit{while}-Schleife abgearbeitet, dies ist in den Zeilen 101 - 116 im \autoref{lst:content_imple_input_lessons} zu sehen. In dieser Schleife werden noch einige Dinge zusätzlich abgefragt.\\
Um Teilungen aus den Rückgabewerten besser zu erkennen, wird hier mit der SQL-Abfrage in Zeile 102-109 die Anzahl der Teilungen der aktuell bearbeiteten Stunde/n abgefragt. Dies wird in Zeile 114 in eine zusätzliche Spalte des Arrays geschrieben. Anschließend wird das modifizierte Array dem Array \texttt{\$content} angefügt. Diese Prozedur wird mit allen Rückgabewerten durchgeführt.\\
\lstinputlisting[style=custom, language=php, caption={/backend/administration/lessons/lessons.php; Zeile 96 - 118},  label={lst:content_imple_input_lessons}, firstline =96, lastline = 118, firstnumber = 96 ]{sources/input/lessons.php}
\paragraph{Routine\\}
Da alle Zeilen für alle Stunden und Teilungen von beginn an erstellt werden, wird die Erstellroutine insgesamt (7 Teilungen \'{a} 16 Stunden ergibt 112) 112 mal durchlaufen. Dabei werden die Zeilen für die Teilungen, bei einem leeren Tag nicht sichtbar und bei einem schon eingetragenen Tag dementsprechend sichtbar oder unsichtbar erstellt. Bei den zusätzlichen Teilungszeilen werden die Informationen über Länge der Stunde, Startstunde und Anzahl der Teilungen nicht angezeigt. Da sie für das Eintragen in der Datenbank benötigt werden, werden diese Daten in \textit{hidden}-Felder gespeichert.\\
Um zwischen der ersten Zeile und der zusätzlichen 6 Teilungszeilen zu unterscheiden wird die Moduldivision verwendet. Die Moduldivision dividiert eine Zahl und gibt den Rest bei der Division als Ergebnis zurück. Da im \texttt{\$content} unter Umständen die Einträge nicht in der richtigen Reihenfolge enthalten sind, muss immer der gesamte Inhalt durchlaufen werden. Wird die richtige Stunde gefunden, dann wird aus der \texttt{\$content} Variable ein neues Array erstellt, welches genau dem Inhalt entspricht, der in die Input-Felder geschrieben werden muss.\\
Auch bei der Eingabemaske der Stundenpläne muss mittels JavaScript auf die Zeilen zugegriffen werden können, dazu braucht jede Zeile eine eindeutige ID. Diese wird hier mittels der Nummer der Teilung (1-7) und der Stunde gebildet.\\ 
Zum Beispiel:
\begin{itemize}
	\item Die erste Zeile der 2. Stunde hat die ID: visibleRow12
	\item Die dritte Zeile der 15. Stunde hat die ID: visibleRow315
\end{itemize}
Da auch auf den Inhalt der Text Box für die Teilung zugegriffen werden muss, erhät auch diese eine eindeutige ID, diese wird nur aus der Stunde gebildet, da es dies nur einmal pro Stunde gibt. Auch auf die Text Box für die Länge muss zugegriffen werden, diese ID wird aus der Stunde generiert.\\
Zum Beispiel:
\begin{itemize}
	\item Die Text Box für die Teilung der 1. Stunde hat die ID: visibilityText1
	\item Die Text Box für die Länge der 3. Stunde hat die ID: visibleHour3
\end{itemize}
Um beim Erstellen und Befüllen der Eingabemaske die richtigen Felder sichtbar bzw. unsichtbar zu schalten. wird nach dem erstellen einer Stunde(7 Zeilen pro Stunde) wird eine JavaScript Funktion ausgeführt und die Zeilen werden dementsprechend ein- und ausgeblendet.
In den nächsten Punkten werden die Codezeilen in einzelnen Teilen zerlegt und genauer erklärt.
\begin{enumerate}

	\item \autoref{lst:content_imple_input_form_lessons_1}\\
	In diesem Codeabschnitt wird die Unterscheidung zwischen der ersten Zeile und den zusätzlichen Zeilen für die Teilung unterschieden.\\
	Mit der Moduldivision in der \textit{If}-Bedingung wird überprüft, ob es sich um die erste Zeile einer Stunde handelt. Die Variable \texttt{\$zeile} startet bei der Zählung mit 0 und endet bei 111. Sie wird bei jeder erstellten Zeile um 1 erhöht.\\
	Beispiel zur Berechnung:
	
	\begin{itemize}
		\item \texttt{\$zeile} = 10\\
		Dies entspricht der 4. Zeile aus der 2. Stunde.\\
		$ \$zeile \% 7 = 10 \% 7 = 3 \ne 0 \Rightarrow $ Nicht erste Zeile
		\item \texttt{\$zeile} = 14\\
		Dies entspricht der 1. Zeile aus der 3. Stunde.\\
		$ \$zeile \% 7 = 14 \% 7 = 0 \Rightarrow $ Erste Zeile
	\end{itemize}
	
	Durch dieses Verfahren kann jederzeit bestimmt werden, ob es die erste Zeile oder eine der zusätzlichen Zeilen ist.\\
	Handelt es sich um die erste Zeile, dann werden folgende Dinge gemacht:
	
	\begin{itemize}
		\item die Variable \texttt{\$zeile1} auf 1 gesetzt, um zu erkennen, dass es sich um die erste Zeile handelt
		\item die momentane Stunde wird berechnet und in die Variable \texttt{\$hour} geschrieben\\
		Berechnung:
		\begin{itemize}
			\item \texttt{\$zeile} = 0\\
			$ ( \dfrac{\$zeile}{7} ) + 1 = ( \dfrac{0}{7} ) + 1 = 1 \Rightarrow $ 1. Stunde
			\item \texttt{\$zeile} = 21\\
			$ (\dfrac{\$zeile}{7}) + 1 = ( \dfrac{21}{7} ) + 1 = 4 \Rightarrow $ 4. Stunde\\
		\end{itemize}
		\item die Sichtbarkeit der Zeile wird in die Variable \texttt{\$visibility} geschrieben, da es sich um die erste Zeile handelt wird diese sichtbar erstellt.
	\end{itemize}
	
	Handelt es sich jedoch um eine zusätzliche Zeile, dann werden folgende Dinge gemacht:
	
	\begin{itemize}
		\item die Variable \texttt{\$zeile1} auf 0 gesetzt, um zu erkennen, dass es sich nicht um die erste Zeile handelt
		\item die momentane Stunde wird berechnet und in die Variable \texttt{\$hour} geschrieben, dabei wird die PHP-Funktion \texttt{floor} benötigt, diese Funktion rundet das Ergebnis auf eine Integer-Zahl ab.\\
		Berechnung:
		
		\begin{itemize}
			\item \texttt{\$zeile} = 2\\
			$ floor(\dfrac{\$zeile}{7}) + 1 = floor( \dfrac{2}{7} ) + 1 = 1 \Rightarrow $ 1. Stunde
			\item \texttt{\$zeile} = 17\\
			$ floor(\dfrac{\$zeile}{7}) + 1 = floor( \dfrac{17}{7} ) + 1 = 3 \Rightarrow $ 3. Stunde\\
		\end{itemize}
		
		\item die Sichtbarkeit der Zeile wird in die Variable \texttt{\$visibility} geschrieben, da es sich nicht um die erste Zeile handelt wird diese unsichtbar erstellt.
	\end{itemize}
	
	In Zeile 123 wird die eindeutige ID dieser Zeile berechnet, die nach dem, schon genannten, Prinzip aufgebaut ist.\\
	Beispiel zur Berechnung:
	
	\begin{itemize}
		\item \texttt{\$zeile} = 17 und \texttt{\$hour} = 3\\
		$ (\$zeile + 1 - ((\$hour - 1 ) \ast 7)) =  (17 + 1 - ((3 - 1) \ast 7)) = 4 \Rightarrow $ 4. Zeile
		\item \texttt{\$zeile} = 7 und \texttt{\$hour} = 2\\
		$ (\$zeile + 1 - ((\$hour - 1 ) \ast 7)) =  (7 + 1 - ((2 - 1) \ast 7)) = 1 \Rightarrow $ 1. Zeile
	\end{itemize}
	
	In Zeile 124 wird das Array für den Inhalt der Input-Felder definiert und vorbelegt. Dabei wird Standardmäßig bei den Indizes \texttt{split} und \texttt{length} 1 als Wert geschrieben, diese Werte werden jedoch, wenn nötig, abgeändert.\\
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 112 - 124},  label={lst:content_imple_input_form_lessons_1}, firstline =112, lastline = 124, firstnumber = 112 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_form_lessons_2}\\
	Dieser Codeauschnitt wird nur abgearbeitet wenn ein Inhalt mitgegeben wird. Wie schon oben erwähnt, muss jede Zeile des mehrdimensionalen Arrays \texttt{\$content} jedes mal durchlaufen werden. Mit den richtigen Daten wird das Array\texttt{\$stuff} befüllt, welches zum füllen der Input-Felder verwendet wird.\\
	In Zeile 127 wird die Variable \texttt{\$index} mit der \texttt{unset}-Funktion gelöscht, um keine Störungen zu verursachen. Mit der \textit{foreach}-Schleife wird der \texttt{\$content} durchlaufen. Dabei wird jede einzelne Zeile als eindimensionales Array in die Variable \texttt{\$c} kopiert. In der Variable \texttt{\$i} steht der aktuellen Index der Position im Array \texttt{\$content}.\\
	In der Zeile 129 wird geprüft, ob für die Stunde der aktuellen Zeile ein Eintrag gefunden wird. Dazu muss die Stunde mit der Start-Stunde  im Inhalt übereinstimmen.\\
	In den Zeilen 131 - 138 werden alle benötigten Werte in ein Variable geschrieben, die anschließend in der Zeile 139 in das zuvor definierte Array \texttt{\$stuff} geschrieben werden.  In Zeile 141 wird der aktuell verwendete Inhalt aus dem Array \texttt{\$conent} gelöscht.\\ Da bei gefundenem Inhalt die \textit{\$foreach}-Schleife abgebrochen werden kann, wird in der zeile 143 überprüft, ob etwas gefunden wurde, wenn ja dann wird mit \texttt{break} abgebrochen.\\
	Die Zeilen 147 - 150 sind dazu zuständig, die Stunden auszublenden, welche wegen der Länge einer vorherigen Stunde nicht notwendig sind. Dabei wird auf 4 Bedingungen geprüft:
	
	\begin{itemize}
		\item Ist von der letzten, mit Inhalt befüllten, Stunde eine Länge angegeben
		\item Ist diese Länge größer als 1, wenn nicht, dann muss keine Stunde ausgeblendet werden, da die Stunde nur eine Stunde lang ist.
		\item Ist die aktuelle Zeile eine andere Stunde, wie die zuletzt befüllte Stunde
		\item Ist es die erste Zeile, da die zusätzlichen Zeilen sowieso ausgeblendet sind.
	\end{itemize}
	
	Treffen alle diese Bedingungen zu, dann wird die Länge um eins verringert und die Variable \texttt{\$visibility} verändert.\\
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 126 - 151},  label={lst:content_imple_input_form_lessons_2}, firstline =126, lastline = 151, firstnumber = 126 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_form_lessons_3}\\
	In dieser Codesequenz werden die einzelnen Input-Typen für eine Zeile erstellt. Dabei wird, wie in den anderen Routinen auch, das \texttt{\$field}-Array durchlaufen. Mittels \textit{If}-Abfrage wird der Input-Typ ausgewählt.\\
	In den Zeilen 159 - 165 wird geprüft, ob Inhalt eingefügt werden muss oder nicht. Dies wird mittels der Variable \texttt{\$index} überprüft, ist diese Variable gesetzt, dann muss ein Inhalt eingefügt werden. Außerdem wird auch die Variable \texttt{\$edit} auf \texttt{readonly} gesetzt, diese wird später benötigt, um die Felder Länge und Teilung zu sperren. Dies hat den Hintergrund, dass es zu Problemen kommen kann, wenn diese 2 Parameter geändert werden, wenn schon Daten vorhanden sind.\\
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 159 - 167},  label={lst:content_imple_input_form_lessons_3}, firstline =159, lastline = 167, firstnumber = 159 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_form_lessons_4}\\
	Der unterschied zu den anderen Routinen besteht darin, dass wenn das \textit{hidden}-Feld ID erstellt wird, auch einige weitere Felder erstellt werden, abhängig um welche Zeile es sich handelt.\\
	Wird das ID-Feld in der ersten Zeile einer Stunde erstellt, dann müssen Teilung, Stunde, Länge sichtbar sein. Wenn es sich jedoch um eine zusätzliche Zeile für die Teilungen handelt, dann müssen diese vorhanden sein, jedoch nicht sichtbar. Dazu wird hier in der \textit{If}-Bedingung zwischen Zeile 1 (\texttt{\$zeile1=1}) und zwischen den anderen zusätzlichen Zeilen unterschieden.\\
	Nach der \textit{If}-Abfrage werden noch 2 zusätzliche Hidden-Felder erzeugt, in welchen die Information über die Klasse und des Wochentages gespeichert wird.\\
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 175 - 190},  label={lst:content_imple_input_form_lessons_4}, firstline =175, lastline = 190, firstnumber = 175 ]{sources/input/form.php}
	
	\item \autoref{lst:content_imple_input_form_lessons_5}\\
	Da immer nur eine Stunde mit deren Teilungen gelöscht werden kann, wird nur in der ersten Zeilen jeder Stunde eine Lösch-Funktion eingefügt. Dies wird mit den Zeilen 198 - 203 unterschieden.\\
	Am Ende jeder Stunde wird die JavaScript-Funktion \texttt{Visibility} ausgeführt. (siehe Abschnitt \nameref{sec:content_imple_input_java_lessons}).\\
	In der Zeile 208 wird die Zeilenanzahl um 1 erhöht. Am Ende der Funktion wird die Abbruchbedingung der \textit{Do-While}-Schleife definiert. Wie schon erwähnt werden 112 Zeilen benötigt, da die Zählung der Zeilenzahl bei 0 beginnt, bricht die Bedingung ab wenn die Zeilennummer 111 übersteigt.\\
	
	\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 198 - 209},  label={lst:content_imple_input_form_lessons_5}, firstline =198, lastline = 209, firstnumber = 198 ]{sources/input/form.php}
	
\end{enumerate}

\paragraph{Stundenplan JavaScript} $ ~~ $\\ \label{sec:content_imple_input_java_lessons}
Für die Eingabemaske der Stundenpläne werden 4 JavaScript Funktionen benötigt.
\begin{enumerate}
	\item \texttt{visibility()}\\
	Diese Funktion übernimmt die Aufgabe, die zusätzlichen Zeilen für die Teilungen ein- bzw. auszublenden. Dieser Funktion muss als Parameter die Stunde mitgegeben werden.\\
	Um sich nur auf die 7 Teilungen zu beschränken und Fehleingaben abzuwehren, wird mit dem eingegebenen Text ein \textit{Switch-Case} durchlaufen. Wird die eingegebene Zahl gefunden, so wird diese übernommen, wird sie nicht gefunden, wird als Teilung 1 angenommen.\\
	Anschließend werden zuerst alle Zeilen ausgeblendet und dann nach der Reihe wieder eingeblendet.
	
	\lstinputlisting[style=custom, language=java, caption={/data/scripts/lesson.js; Zeile 8 - 49},  label={lst:content_imple_input_form_lessons_java_1}, firstline =8, lastline = 49, firstnumber = 8 ]{sources/input/lessons.js}
	
	\item \texttt{text()}\\
	Mit dieser Funktion wird ein Text, der mit dem Parameter \texttt{text} der Funktion übergeben wird, in alle Zeilen einer Stunde geschrieben. Die Stunde wird mit dem Parameter \texttt{hour} mitgegeben.
	
	\lstinputlisting[style=custom, language=java, caption={/data/scripts/lesson.js; Zeile 51 - 62},  label={lst:content_imple_input_form_lessons_java_2}, firstline =51, lastline = 62, firstnumber = 51 ]{sources/input/lessons.js}
	
	\item \texttt{changeText()}\\
	Diese Funktion schreibt den, in das Teilungsfeld, eingegebenen Text in alle anderen Zeilen der Stunde. Die Stunde wird mit dem Parameter \texttt{hour} übergeben.
	
	\lstinputlisting[style=custom, language=java, caption={/data/scripts/lesson.js; Zeile 64 - 76},  label={lst:content_imple_input_form_lessons_java_3}, firstline =64, lastline = 76, firstnumber = 64 ]{sources/input/lessons.js}
	
	\item \texttt{visibleHours()}\\
	In dieser Funktion werden die Stunden ausgeblendet, welche nicht benötigt werden, aufgrund der Länge einer vorherigen Stunde. Dieser Funktion wird mit dem Parameter \texttt{hour} die Stunde mitgegeben.\\
	Zuerst werden alle Zeilen ab der mitgegebenen Stunde, die als Länge 1 haben, sichtbar gemacht. Anschließend werden, der Länge entsprechend, die Stunden ausgeblendet.
	
	\lstinputlisting[style=custom, language=java, caption={/data/scripts/lesson.js; Zeile 78 - 105},  label={lst:content_imple_input_form_lessons_java_4}, firstline =78, lastline = 105, firstnumber = 78 ]{sources/input/lessons.js}
	
\end{enumerate}

\subsubsection{Erstellen des Übernehmen Buttons} \label{sec:content_input_savedelete}
Die Funktion \texttt{form\_savedelete} erstellt, je nach mitgegebenen Parameter, eine Check Box fürs Löschen und einen Übernehmen-Button oder nur einen Übernehmen-Button.\\
Als Parameter wird dieser Funktion \texttt{\$new} mitgegeben. Dieser Parameter kann den Wert \texttt{false} oder \texttt{true} annehmen. Bei \texttt{false} wird beides erstellt, bei \texttt{true} nur der Übernehmen-Button.
\lstinputlisting[style=custom, language=php, caption={/modules/form/form.php; Zeile 386 - 396},  label={lst:content_imple_input_form_saveDelete}, firstline =386, lastline = 396, firstnumber = 386 ]{sources/input/form.php}

\subsubsection{Erstellen der Listenfelder}
Für das Erstellen der Listen, für die Listenfelder, wurde eine eigene Funktion entwickelt, welche nur die Listen erstellt. Die benötigten Listen werden einmal, beim Aufrufen einer Seite, erstellt und auf diese kann man auf der ganzen Seite, mit dem definierten Namen, zugreifen.\\
Es werden dabei nicht alle möglichen Listen erstellt, sondern man muss ein Array mit den Namen der gewünschten Listen erstellen. Dies muss definiert werden, bevor der \texttt{include} der Datei für die Listenfelder gemacht wird. (siehe Beispiel \autoref{lst:content_imple_input_form_listen})


\lstinputlisting[style=custom, language=php, caption={/backend/administration/lessons/lessons.php; Zeile 60 - 61},  label={lst:content_imple_input_form_listen}, firstline =60, lastline = 61, firstnumber = 60 ]{sources/input/lessons.php}

Im Beispiel-\autoref{lst:content_imple_input_form_listen} ist in der Zeile 60 die Definition des Arrays zu sehen. Der Name \texttt{\$dropDown} ist zwingend notwendig, auch die Namen der gewünschten Listen können nicht willkürlich gewählt werden. Hier die zur Auswahl stehenden Listen:
\begin{itemize}
	\item Sections: Abteilungskürzel
	\item Teachers: Lehrerkürzel
	\item Rooms: Raumnamen
	\item Subjects: Fächerkürzel
	\item Classes: Klassennamen
	\item ClassesSub: Klassen nur für eine Abteilungen, benötigt bei den Supplierungen. \\
	Wichtig: \texttt{\$section}-Variable muss mit dem Abteilungs-Kürzel belegt sein.
	\item Days: Wochentage von Mo - Fr
\end{itemize}
Für das Erstellen der Listen ist es nicht notwendig eine Funktion aufzurufen. Es muss einzig die Datei \textit{/modules/form/dropdownSelect.php} inkludiert werden.(siehe \autoref{lst:content_imple_input_form_listen} Zeile 61)\\
Im \autoref{lst:content_imple_input_drop} ist zu sehen wie die Liste für die Abteilung erstellt wird.\\
In der Zeile 14 wird abgefragt, ob diese Liste erstellt werden soll. In der Zeile 15 werden alle Abteilungskürzel aus der MySQL-Tabelle abgefragt. Diese Daten werden in Zeile 16 an die Funktion \texttt{create} mitgegeben. Außerdem muss dieser Funktion auch der Listennamen, mit dem auf die Liste zugegriffen werden kann, mitgegeben werden.
\lstinputlisting[style=custom, language=php, caption={/modules/form/dropdownSelects.php; Zeile 13 - 17},  label={lst:content_imple_input_drop}, firstline =13, lastline = 17, firstnumber = 13 ]{sources/input/dropdownSelects.php}
Im \autoref{lst:content_imple_input_drop_create} ist die Funktion \texttt{create} zu sehen.\\
In den Zeilen 66 - 68 werden alle Datensätze in ein Array geschrieben. In Zeile 72 - 74 wird das Array durchlaufen und es werden die Einträge der Liste erstellt.
\lstinputlisting[style=custom, language=php, caption={/modules/form/dropdownSelects.php; Zeile 61 - 77},  label={lst:content_imple_input_drop_create}, firstline =61, lastline = 77, firstnumber = 61 ]{sources/input/dropdownSelects.php}

\subsubsection{Erstellen der Datumsauswahl}
In den Formularen für die Supplierungen und den Fehlenden kann das Datum ausgewählt werden. Dafür wurde eine eigene Funktion entwickelt, welche durch das inkludieren der Datei \textit{/modules/other/dateChange.php} verwendet wird. Anschließend muss noch an der gewünschten Stelle die Funktion \texttt{dateChange} aufgerufen werden. Diese Funktion erwartet als Parameter ein Datum. Im \autoref{lst:content_imple_input_change_include} ist ein Aufruf der Funktion und die benötigten Codezeilen, um die Rückgabewerte zu interpretieren, zu sehen.\\
Wird weder über das Formular zum Ändern des Datums, noch über das Speichern eines Eintrags das aktuelle Datum mitgegeben, wird das heutige Datum verwendet, siehe dazu Zeile 58. Wird das Datum mit dem Formular zum Ändern des Datums übergeben, so wird dieser Wert verwendet, siehe dazu Zeile 62. Die letzte Möglichkeit ist über das Speichern eines Eintrages, dann wird dieses Datum verwendet, siehe dazu Zeile 65. Das Datum wird immer der Funktion \texttt{no\_weekend} übergeben. (siehe Abschnitt \nameref{sec:content_imple_date}) In der Zeile 68 wird die Funktion aufgerufen, welche das Formular für die Änderung des Datums erstellt. Der Rückgabewert dieser Funktion wird als neues Datum verwendet, denn diese Funktion übernimmt die Auswertung der Datumsänderung. 

\lstinputlisting[style=custom, language=php, caption={/backend/absentees/classes/index.php; Zeile 57 - 68},  label={lst:content_imple_input_change_include}, firstline =57, lastline = 68, firstnumber = 57 ]{sources/input/missingClasses.php}

In den Zeilen 7 - 12 wird die Auswertung durchgeführt, welche notwendig ist, um zu erkennen welcher Pfeil gedrückt worden ist. Wird der rechte Pfeil gedrückt, so wird die Zeile 8 ausgeführt, wird der linke Pfeil gedrückt wird die Zeile 11 ausgeführt. (\texttt{date\_increase} und \texttt{date\_decrease} siehe Abschnitt \nameref{sec:content_imple_date})\\
In den Zeilen 16 - 29 wird das Formular erstellt. In der Zeile 32 wird das aktualisierte Datum zurückgegeben.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateChange.php; Zeile 5 - 33},  label={lst:content_imple_input_change_fun}, firstline =5, lastline = 33, firstnumber = 5 ]{sources/input/dateChange.php}

\paragraph{Date-Funktionen}
\label{sec:content_imple_date}
$ ~~ $\\
In der Datei \textit{/modules/other/dateFunctions.php} sind einige Funktionen definiert, welche das Verarbeiten von Daten betrifft. Hier die 5 Funktionen, die in den Formularen benötigt werden.\\

\subparagraph{\texttt{date\_increase()}\\}
Diese Funktion inkrementiert das, über den Parameter \texttt{\$d} mitgegebene, Datum um einen Tag. Sollte das inkrementierte Datum auf ein Wochenende fallen, so wird es solange inkrementiert, bis das Datum auf kein Wochenende fällt.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateFunctions.php; Zeile 52 - 61},  label={lst:content_imple_input_increase}, firstline =52, lastline = 61, firstnumber = 52 ]{sources/input/dateFunctions.php}

\subparagraph{\texttt{date\_decrease()}\\}
Diese Funktion dekrementiert das, über den Parameter \texttt{\$d} mitgegebene, Datum um einen Tag. Sollte das dekrementierte Datum auf ein Wochenende fallen, so wird es solange dekrementiert, bis das Datum auf kein Wochenende fällt.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateFunctions.php; Zeile 64 - 73},  label={lst:content_imple_input_decrease}, firstline =64, lastline = 73, firstnumber = 64 ]{sources/input/dateFunctions.php}

\subparagraph{\texttt{no\_weekend()}\\}
Diese Funktion prüft, ob das, über den Parameter \texttt{\$d} mitgegebene, Datum  auf einen Wochentag fällt. Fällt es auf ein Wochenende, so wird das Datum solange inkrementiert bis es nicht mehr auf ein Wochenende fällt.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateFunctions.php; Zeile 76 - 84},  label={lst:content_imple_input_weekend}, firstline =76, lastline = 84, firstnumber = 76 ]{sources/input/dateFunctions.php}

\subparagraph{\texttt{prevNextDay()}\\}
Diese Funktion wird in dem Formular für die Stundenpläne benötigt. Dabei wird von einem Wochentag der vorherige und der nächste zurückgegeben. Dabei endet die Woche mit Freitag und startet mit Montag.\\
Mit der \textit{If}-Abfrage wird zwischen den 3 Varianten unterscheiden. Die erste trifft zu, wenn der Wochentag Di - Do ist. Die zweite Abfrage, wenn der Wochentag der Montag ist und die letzte für den Freitag. Am Ende der Funktion wird ein Array mit den beiden Wochentagen zurück.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateFunctions.php; Zeile 26 - 49},  label={lst:content_imple_input_nextday}, firstline =26, lastline = 49, firstnumber = 26 ]{sources/input/dateFunctions.php}

\subparagraph{\texttt{weekday}\\}
Diese Funktion gibt für das, über den Parameter \texttt{\$d} mitgegebene, Datum  den Wochentag in Kurzform zurück. Die möglichen Wochentage sind Mo - So.

\lstinputlisting[style=custom, language=php, caption={/modules/other/dateFunctions.php; Zeile 12 - 17},  label={lst:content_imple_input_weekday}, firstline =12, lastline = 17, firstnumber = 12 ]{sources/input/dateFunctions.php}